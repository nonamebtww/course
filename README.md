# Анализ функции

Консольная программа для анализа функции f(x). Позволяет вычислять значение функции в точке, строить таблицу значений на отрезке, численно вычислять определённый интеграл (метод Симпсона) и приближённо вычислять производную в точке (центральная разностная формула).

> Дальше приведены постановка задачи, структура проекта, описание алгоритма и ключевых функций, примеры запуска и формат данных.

---

## 1) Постановка задачи

Реализовать средство анализа функции f(x), определённой кусочно:

- Для x < -1:
  f(x) = (e^{-x^2} - 1) / x^2 (с учётом исключений при x == 0)
- Для -1 ≤ x < 6:
  f(x) = x * sin(sqrt(1 + x^2))
- Для x ≥ 6:
  f(x) = ln(7*x^2 - 4*x + 8)

Функционал программы:
- Вычисление f(x) в конкретной точке.
- Построение таблицы x → f(x) на заданном интервале с указанным числом разбиений.
- Численное вычисление определённого интеграла на отрезке [a, b] методом Симпсона.
- Приближённое вычисление производной f'(x) в точке (центральная формула разности).

Программа должна корректно обрабатывать недопустимые/граничные входные значения и возвращать понятный признак ошибки.

---

## 2) Структура проекта

Текущая структура:

- `course/`
  - `src/`
    - `functions.c`      — реализация `f`, `interval`, `integral`, `derivative`
    - `menu.c`           — консольное меню и обработчики ввода/вывода
    - `logging.c` 	     — модуль логирования
  - `headers/`
    - `models.h`         — определение структуры `MapEntry`
    - `functions.h`      — объявления функций
    - `menu.h` 		     — объявления функций меню
    - `logging.h` 	     — объявления функций логирования
  - `course.sln` / `*.vcxproj`  — файлы Visual Studio
  - `README.md`         — этот файл
  - `CMakeLists.txt`    — CMake-конфигурация для сборки проекта при помощи CMake

---

## 3) Ключевые функции (описание и контракт)

В проекте используется структура:

`typedef struct { double key; double value; } MapEntry;`

Описание функций (интерфейсы в `headers/functions.h`):

- `double f(double x)`
  - Возвращает значение функции f в точке x.
  - Если вход недопустим (NaN, Inf) или полученное выражение не определено (деление на 0, логарифм не положителен), возвращает `NAN`.

- `MapEntry* interval(double lowest_limit, double highest_limit, int count_steps)`
  - Вычисляет таблицу значений функции на отрезке [lowest_limit, highest_limit], разделённом на `count_steps` равных частей.
  - Возвращает указатель на динамически выделенный массив из `count_steps + 1` элементов `MapEntry`.
  - На ошибку (некорректные аргументы, ошибка выделения памяти) возвращает `NULL`.
  - Обязанность освобождения памяти — на вызывающей стороне (вызывать `free`).

- `MapEntry* integral(double lowest_limit, double highest_limit, int count_steps)`
  - Вычисляет численное значение определённого интеграла по методу Симпсона на отрезке [lowest_limit, highest_limit].
  - Если `count_steps` нечётное, он увеличивается на 1 (требование для Симпсона).
  - Возвращает `MapEntry*`, у которого `key` содержит (по текущей реализации) `lowest_limit`, а `value` — вычисленное значение интеграла.
  - На ошибку возвращает `NULL`. Память выделяется внутри и должна быть освобождена вызывающей стороной.

- `MapEntry* derivative(double lowest_limit, double highest_limit, int count_steps)`
  - Выполняет приближённый расчёт производной в точке `x = lowest_limit` по центральной формуле:
    (f(x + eps) - f(x - eps)) / (2 * eps), где eps = (highest_limit - lowest_limit) / count_steps.
  - Возвращает `MapEntry*`, у которого `key` содержит `x` (нижний предел), `value` — значение производной.
  - На некорректный ввод возвращает `NULL`. Память тоже освобождается вызывающей стороной.

---

## 4) Контрольные примеры (вход → ожидаемый формат вывода)

Ниже несколько примеров работы и ожидаемого вывода.

1) Вычисление значения f(x)

Ввод:
- Выберите действие: `1`
- Введите x: `2`

Пример вывода:
- `f(x) = 1,573498`

2) Таблица значений на отрезке

Ввод:
- Выберите действие: `2`
- Введите начало: `0`
- Введите конец: `1`
- Введите количество разбиений: `4`

Пример вывода (формат):
- `0.000000 | 0.000000`
- `0.250000 | 0,214425`
- `0.500000 | 0,449621`
- `0.750000 | 0,711738`
- `1.000000 | 0,987766`

(Значения приведены для примера; фактические значения зависят от реализации `f`)

3) Интеграл

Ввод:
- Выберите действие: `3`
- Нижний предел: `0`
- Верхний предел: `2`
- Количество шагов: `100`

Вывод:
- `Интеграл: 1,865845`

4) Производная

Ввод:
- Выберите действие: `4`
- Введите нижний предел: `1`
- Введите верхний предел: `1.1`
- Количество разбиений: `100`

Вывод:
- `Производная: 1,098034`

Контрольные численные значения: в README оставлены как ориентир; для строгой проверки добавьте юнит-тесты и эталонные значения в файл `tests/`.

---

## 5) Формат данных и соглашения

- `MapEntry` — пара (key, value) типа `double`.
  - `key` используется для хранения координаты x в таблице или той точки, к которой относится вычисленное значение.
  - `value` — числовой результат (f(x), значение интеграла, приближённая производная).
- Все функции, возвращающие `MapEntry*`, выделяют память через `malloc`. Обязанность использовать `free()` после исполнения.
- При ошибках (некорректный ввод, переполнение, невозможность вычисления) функции возвращают `NULL` или `NAN`.

---

## Сборка и запуск (Visual Studio и CMake)

В проекте поддерживаются два способа сборки и запуска на Windws - при помощи Visual Studio:

- Откройте `course.sln` в Visual Studio и соберите решение через меню "Build -> Build Solution".
- Запустите приложение из среды (F5) или запустите собранный исполняемый файл вручную.

---

- Автор: Горяйнов Павел Андреевич
- Группа: бИЦ-252